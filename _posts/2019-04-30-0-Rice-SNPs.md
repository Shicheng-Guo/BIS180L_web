---
title: "Rice SNPs"
layout: lab
tags:
- R
- SNPs
hidden: true
---



## Getting Started
* I have created a new repository  called `Assignment_4` and have placed an `Assignment_4_template.Rmd` file there.  
* Clone the repository into a new Rstudio Project
* Download the file [RiceSNPData.zip]({{site.baseurl}}/data/RiceSNPData.zip), unzip it, and place the files into the `Assigment_4` directory.
* Open the `Assignment_4_worksheet.Rmd` file and use that for your answers 

## Preliminaries

Let's load the libraries we need:




## Some new tools

We begin by learning a few new tools to help us with the upcoming data sets.
    
### reshaping data.

Spreadsheet data is often organized in a "wide" format where there is one row per individual and then multiple traits measured on that individual are in separate columns.  This is a convenient format for data entry, but R often wants data in a "long" format with one observation per row.  Please work through the Gather And Spread tutorial to learn more about these formats and how to convert:



(If you haven't already installed the tutorial packages, you can do so with:)

```
## Skipping install of 'BIS180LTutorials' from a github remote, the SHA1 (ee48e55a) has not changed since last install.
##   Use `force = TRUE` to force installation
```


### applying functions across rows or columns
It is very common to want to apply a function to each row.  We can use the `apply()` function for this.  `apply` takes at least 3 arguments.

`apply(X,MARGIN,FUN)`
where
* X is a data frame or matrix
* MARGIN is whether to apply a function to each row (1) or each column (2)
* FUN is the function that you want to use

For example

```
##             [,1]       [,2]        [,3]        [,4]       [,5]        [,6]
## [1,] -0.55438961  0.1880410 -0.02346866  2.05008228  1.5860737 -1.94907326
## [2,] -0.03332531 -1.3552478  2.05884515 -0.73731196  0.7327968  0.04086489
## [3,]  0.90708508 -0.6104206  0.06922946 -0.13225697  0.2283865 -1.86435415
## [4,]  0.69465513  0.9413514 -1.52497979 -0.03033662 -0.2293635 -1.40842629
```

```
## 
## row minimums:
```

```
## [1] -1.949073 -1.355248 -1.864354 -1.524980
```


**PRACTICE (not graded)** find the mean of each _column_ of m using apply

### Alternatives

For some key functions there are pre-defined convenience functions



## Lets get started with the real data

### Data Import
You learned how to import data last week using `read_csv()`.  Note that read_csv can read in a .gzipped file directly.  Today we will provide an additional argument to the read_csv function:

```
## Warning: Missing column names filled in: 'X1' [1]
```

```
## Warning: Duplicated column names deduplicated: '6_17160794' =>
## '6_17160794_1' [22253]
```

```
## Parsed with column specification:
## cols(
##   .default = col_character()
## )
```

```
## See spec(...) for full column specifications.
```

Use `dim()` to determine the numbers of rows and columns.  (You can also look at the info in the right-hand pane).  There are 413 rows and 36,901 columns.  Generally I recommend looking at files after they have been read in with the `head()` and `summary()` functions but here we must limit ourselves to looking at a subset of what we read in.



In this file each row represents a different rice variety and each column a different SNP. The column "X1" ("NSFTV1") gives the ID of each variety.  "X1" is not a very informative name (that column did not have a name in the data file and R assigned it the name "X1".) Let's rename it:


```
## # A tibble: 6 x 20
##   ID    `1_13147` `1_73192` `1_74969` `1_75852` `1_75953` `1_91016`
##   <chr> <chr>     <chr>     <chr>     <chr>     <chr>     <chr>    
## 1 NSFT… TT        TT        CC        GG        TT        AA       
## 2 NSFT… CC        CC        CC        AA        GG        <NA>     
## 3 NSFT… CC        CC        CC        AA        GG        GG       
## 4 NSFT… CC        CC        TT        GG        GG        AA       
## 5 NSFT… CC        CC        CC        AA        GG        GG       
## 6 NSFT… TT        TT        CC        GG        TT        AA       
## # … with 13 more variables: `1_146625` <chr>, `1_149005` <chr>,
## #   `1_149754` <chr>, `1_151492` <chr>, `1_152899` <chr>,
## #   `1_172755` <chr>, `1_172923` <chr>, `1_173692` <chr>,
## #   `1_195327` <chr>, `1_199011` <chr>, `1_202999` <chr>,
## #   `1_203126` <chr>, `1_205867` <chr>
```

The column names give the chromosome and locations of each SNP.  For example, "1_151492" is a SNP on chromosome 1, base position 151492.

### An MDS Plot.  
Multi-Dimensional Scaling (MDS) plots can be used to display the genetic diversity in a 2D space.  The full 36,901 SNPs take too long to run for this class so we will subset the data.  

To do this we take advantage of the `sample()` function.  Sample takes a random sample of the items it is given.


```
## [1] 7 2 9 5 8
```

We can use this to randomly sample a data frame by rows or columns.

```
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1   11   21   31   41   51   61   71   81    91
##  [2,]    2   12   22   32   42   52   62   72   82    92
##  [3,]    3   13   23   33   43   53   63   73   83    93
##  [4,]    4   14   24   34   44   54   64   74   84    94
##  [5,]    5   15   25   35   45   55   65   75   85    95
##  [6,]    6   16   26   36   46   56   66   76   86    96
##  [7,]    7   17   27   37   47   57   67   77   87    97
##  [8,]    8   18   28   38   48   58   68   78   88    98
##  [9,]    9   19   29   39   49   59   69   79   89    99
## [10,]   10   20   30   40   50   60   70   80   90   100
```

if we want to randomly sample 3 rows, then:


```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    3   13   23   33   43   53   63   73   83    93
## [2,]    1   11   21   31   41   51   61   71   81    91
## [3,]    5   15   25   35   45   55   65   75   85    95
```

** Exercise 1 **

Now, create a data subset that contains a random sample of 5000 SNPs from the full data set.  Place the smaller data set in an object called `data.geno.5000`.  __Very important: you want to keep the first column, the one with the variety IDs, and you want it to be the first column.  AND You do not want it to show up randomly later on in the data set.__  Think about how to achieve this.

Check the dimensions of your subset.  If you don't get the output below, you did something wrong:




```
## [1]  413 5001
```

Make sure that "ID" is the first column

```
## [1] 1
```


Now that we have our smaller subset we can create the MDS plot

`geno.mds` contains the genotypic information rescaled to display in two dimensions.  Now lets plot it.  Make a x-y scatter plot of the data, with "V1" on one axis and "V2" on the other axis.



**EXERCISE 2:** Is there any evidence for populations structure (different sub populations)?  If so, how many sub populations do you think the MDS plot reveals?  What do you make of the individuals that are between the major groups?

Optional: Principal components (PCs) represent an alternative dimensions reduction method.  


```r
##Alternative method for PCA

#missing data is not allowed.  Here I remove columns with missing data.
geno.small <- t(na.omit(t(geno.numeric)))

geno.pc <- prcomp(geno.small)

#Show variance explained by top PCs
plot(geno.pc)

#The PCs themselves are here
head(geno.pc$x)

#you can relate back to the original SNPs by:
head(geno.pc$rotation) #tells you how much each SNP contributed to each PC

#plot it:
qplot(x=PC1,y=PC2,data=as.data.frame(geno.pc$x))
qplot(x=PC1,y=PC3,data=as.data.frame(geno.pc$x))
```

### Adding phenotypes

The file "RiceDiversity.44K.MSU6.Phenotypes.csv" contains information about the country of origin and phenotypes of most of these varieties.  

**EXERCISE 3:** 
* Use the `read_csv()` `head()` and `summary()` functions that you learned earlier to import and look at this file.  Import the file into an object called "data.pheno".
* Use a `join` function to merge the MDS scaled genotype data with the phenotype data. Use summary and head to look at the new object and make sure that it is as you expect.
* Include your code in the .Rmd


```
## Parsed with column specification:
## cols(
##   .default = col_double(),
##   NSFTVID = col_character(),
##   Accession_Name = col_character(),
##   Country_of_Origin = col_character(),
##   Region = col_character(),
##   `Seed color` = col_character(),
##   `Pericarp color` = col_character()
## )
```

```
## See spec(...) for full column specifications.
```




We can now color points on our plot by characteristics in this data set.  

**EXERCISE 4:** Prepare three different plots to explore if subgroups vary by 1) Amylose content; 2) Pericarp color; 3) Region.  Do any of these seem to be associated with the different population groups? Briefly discuss.

*Hint 1* to refer to column names with spaces in the name you can surround the name with backticks, like this:




*Hint 2* use `color=` argument ggplot to color the point by the different traits

*Hint 3* use `size=I(3)` as an argument to increase the point size (you can play with different values)

*Hint 4* when plotting the Region data, the colors will be easier to interpret if you include the following in your ggplot code: ` + scale_color_brewer(type="div")` This specifies that a diverging set of colors is used.  (Try plotting with and without this).





## Assign populations with fastStructure
From the MDS plot it looks like there is structure in our population.  But how do we know which individual belongs in which population?  We can take an alternative approach and assign individuals to specific population classes with [fastStructure](https://rajanil.github.io/fastStructure/), a python program for accomplishing this task.

We have to create three files in order to run fastStructure

### genotype file
First we have to convert our genotypes to the form that fastStructure expects.  fastStructure wants a separate row for each allele (two rows for each variety).  A couple of the commands below are a bit complex.  I will explain them in lab after this has been run.



### Create the .fam file.

The .fam file describes the individuals in the study.  It has a number of columns designed for human studies which do not exactly apply here.

The fields are:

1. Family ID ('FID')
2. Within-family ID ('IID'; cannot be '0')
3. Within-family ID of father ('0' if father isn't in data set)
4. Within-family ID of mother ('0' if mother isn't in data set)
5. Sex code ('1' = male, '2' = female, '0' = unknown)
6. Phenotype value ('1' = control, '2' = case, '-9'/'0'/non-numeric = missing data if case/control)

Since our samples are inbred strains we use the same ID for columns 1 and 2, and 0 for columns 3 and 4.  Rice plants are hermaphroditic, so we use "0" for the sex.  We don't have a phenotype for column 6 for we will put -9 there.


```
## # A tibble: 6 x 6
##   FID    IID      PID   MID   Sex Ptype
##   <chr>  <chr>  <dbl> <dbl> <dbl> <dbl>
## 1 NSFTV1 NSFTV1     0     0     0    -9
## 2 NSFTV3 NSFTV3     0     0     0    -9
## 3 NSFTV4 NSFTV4     0     0     0    -9
## 4 NSFTV5 NSFTV5     0     0     0    -9
## 5 NSFTV6 NSFTV6     0     0     0    -9
## 6 NSFTV7 NSFTV7     0     0     0    -9
```

### create the bim

The bim file provides information on the alleles.  

It contains 6 fields:

1. Chromosome code (either an integer, or 'X'/'Y'/'XY'/'MT'; '0' indicates unknown) or name
2. Variant identifier
3. Position in Morgans or centiMorgans (safe to use dummy value of '0')
4. Base-pair coordinate (normally 1-based, but 0 OK; limited to 231-2)
5. Allele 1 (corresponding to clear bits in .bed; usually minor)
6. Allele 2 (corresponding to set bits in .bed; usually major)


```
##      9_17059264 1_37991133 2_29376785 7_16956824 11_680665
## [1,] "A"        "T"        "G"        "A"        "G"      
## [2,] "G"        "A"        "A"        "C"        "A"
```

```
## # A tibble: 6 x 4
##   V1    V2    SNP_ID         cM
##   <chr> <chr> <chr>       <dbl>
## 1 A     G     9_17059264      0
## 2 T     A     1_37991133      0
## 3 G     A     2_29376785      0
## 4 A     C     7_16956824      0
## 5 G     A     11_680665       0
## 6 C     G     12_23015319     0
```

Next step is to separate the SNP_ID to get chromosome and position

```
## # A tibble: 6 x 6
##   chromosome SNP_ID         cM position allele1 allele2
##   <chr>      <chr>       <dbl> <chr>    <chr>   <chr>  
## 1 9          9_17059264      0 17059264 A       G      
## 2 1          1_37991133      0 37991133 T       A      
## 3 2          2_29376785      0 29376785 G       A      
## 4 7          7_16956824      0 16956824 A       C      
## 5 11         11_680665       0 680665   G       A      
## 6 12         12_23015319     0 23015319 C       G
```


### Run fastStructure

Now we can run fastStructure  fastStructure will determine the proportion of each individual's genome that came from one of K ancestral populations.  This can take a long time to run, so you can just import the results of my previous run of the analysis if you prefer.  The files should be in the zip that you downloaded.

fastStructure is run from the Linux command line.  If you want to run it yourself (optional), open up the terminal and type:


(this will take about 1 minute to run)

In the above command, `-K 4` specifies the number of ancestral populations that fastStructure should create

### Load the fastStructure results

The file `rice.fastStructure.out.4.meanQ` contains 1 row for each sample, and 1 column for each ancestral population.  The numbers give the proportion of the genome inferred to have come from the ancestral population.


```
## Parsed with column specification:
## cols(
##   X1 = col_double(),
##   X2 = col_character(),
##   X3 = col_character(),
##   X4 = col_character()
## )
```


```
## # A tibble: 6 x 4
##         X1 X2          X3          X4         
##      <dbl> <chr>       <chr>       <chr>      
## 1 0.000027 " 0.000027" " 0.000027" " 0.999920"
## 2 0.000028 " 0.999917" " 0.000028" " 0.000027"
## 3 0.000028 " 0.126718" " 0.873226" " 0.000028"
## 4 0.341    " 0.000028" " 0.365809" " 0.292908"
## 5 0.0229   " 0.113023" " 0.864079" " 0.000028"
## 6 0.943    " 0.000028" " 0.039332" " 0.017493"
```

Pay attention to the text "<dbl>" and "<chr>" under the column names above. <dbl> indicates that R interprets the column as containing numeric data and <chr> indicates character data (dbl is short for double-precision floating point numeric data).  Clearly this should all be numeric, bu  fastStructure separates each column with two spaces and R interprets those extra spaces as extra columns.  Let's fix that, and add sample IDs back while we are at it.


```
## # A tibble: 6 x 5
##   ID         pop1     pop2     pop3     pop4
##   <chr>     <dbl>    <dbl>    <dbl>    <dbl>
## 1 NSFTV1 0.000027 0.000027 0.000027 1.000   
## 2 NSFTV3 0.000028 1.000    0.000028 0.000027
## 3 NSFTV4 0.000028 0.127    0.873    0.000028
## 4 NSFTV5 0.341    0.000028 0.366    0.293   
## 5 NSFTV6 0.0229   0.113    0.864    0.000028
## 6 NSFTV7 0.943    0.000028 0.0393   0.0175
```

In the fs_results table, each row is an individual and each column represents one of the hypothesized populations.  
Genomes with substantial contributions from two ancestral genomes are said to be admixed

Let's use these proportions to assign each individual to a particular population.  Of course this can be somewhat problematic for heavily admixed individuals.


If you want to know how many individuals were assigned to each population, you can use `table()`


The fastStructure output must be reformatted in order to plot it well.  Not all of the commands are fully explained below.  If you have questions we can go over this in Friday's discussion.

For plotting it will be helpful to order the samples based on population identity and composition.  To do this, let's make a new column that has the maximum proportion for each sample and then rank them accordingly



Now convert to long format


```
## # A tibble: 6 x 6
##   ID      assignedPop maxPr plot.order population proportion
##   <chr>         <int> <dbl>      <int> <chr>           <dbl>
## 1 NSFTV23           1 1.000          1 pop1            1.000
## 2 NSFTV24           1 1.000          2 pop1            1.000
## 3 NSFTV25           1 1.000          3 pop1            1.000
## 4 NSFTV26           1 1.000          4 pop1            1.000
## 5 NSFTV27           1 1.000          5 pop1            1.000
## 6 NSFTV65           1 1.000          6 pop1            1.000
```

Finally we are ready to plot the results.  In the plot produced below, each column is a single rice variety. The colors correspond to ancestral genomes.  Do you see any evidence of admixture?


### How do these population assignments relate to the MDS plot? 

**EXERCISE 5:** First, use a join function to combine the MDS data with the population assignments and place the result in `geno.mds.  Then re plot the MDS data, but include the population assignment in an informative way.  How do the populations assignments relate to the MDS plot?

**Hint** convert the `assignedPop` variable to a character type before starting, with:









We will use some of the objects that you have created today in Thursday's lab, so lets save them in an .Rdata file for easy loading on Thursday



