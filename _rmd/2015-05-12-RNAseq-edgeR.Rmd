---
type: lab
hidden: true
title: Differential Gene Expression from Illumina RNAseq
output: html_document
---

## Background

The principle behind calling differentially expressed genes is similar to that for other hypothesis-based tests such as ANOVA or t-tests.  We will call genes differentially expressed if the mean expression between treatments is larger than would be expected by chance given the amount of variance among replicates within a treatment type.  However there are several important issues to consider: the first is multiple testing.  Imagine doing a t-test for differential expression on 30,000 genes.  At p < .05 you would expect 5% (600!) of the genes to be called as significantly different by random chance.  This is known as the multiple testing problem and the p-values must be adjusted to compensate for the large number of tests.  Second there are typically very few replicates per treatment reducing power; thankfully techniques have been developed to “share” information between genes to somewhat deal with this issue.  Third, the methods developed for microarray analysis are not directly applicable. Log-transformed microarray data can be effectively modeled as normally distributed.  In contrast RNAseq data is count data and therefore has a different (non-normal) numerical distribution. Consequently statistical models require a different error distribution.

At first glance one might think that the [Poisson distribution](http://en.wikipedia.org/wiki/Poisson_distribution) would be an appropriate model for RNAseq data: reads are discrete events and the chance of a read landing in any particular gene is very low.  Indeed Poisson models were originally tried.  However, in the Poisson distribution the expected mean and variance should be equal.  For most RNAseq data this is not true; the data is overdispersed: the variance is larger than the mean.  Alternatives are the [Negative Binomial](http://en.wikipedia.org/wiki/Negative_binomial_distribution) and Quasi-Poisson models.

It is important to consider an appropriate measure of expression.  While some favor RPKM (Reads per kilobase exon length per million reads mapped), for finding DE genes it is better to normalize counts between samples using a different method (discussed below) and to not adjust for gene length.  Why?  1) the number of reads is not always a linear function of gene length. 2) dividing by gene length causes a loss of information.  By RPKM a gene of 1kb with 10 counts would be treated the same as a 100bp gene with 1 count, but clearly we are much more confident of the expression level when we have 10 counts instead of 1.  This information is lost in RPKM.

Regarding normalization between samples, genes with very high expression levels can skew RPKM type normalization.  Consider two samples where gene expression is the same except that in the first sample RUBISCO is expressed at a very high level, taking up half of the reads.  In the second sample RUBISCO is expressed at a lower level, accounting for 25% of the reads.  By RPKM all non RUBISCO genes will appear to be expressed more highly in the second sample because RUBISO “takes up” fewer reads.  Methods such as [TMM normalization](http://genomebiology.com/2010/11/3/R25) can account for this.

The two packages that I am aware of that effectively deal with the above issues are [DESeq](http://bioconductor.org/packages/release/bioc/html/DESeq.html) and [edgeR](http://www.bioconductor.org/packages/release/bioc/html/edgeR.html), both available through [Bioconductor](http://bioconductor.org/).  We will use edgeR for today's exercises.  


## Preliminaries

We need a couple of additional Bioconductor libraries.  The `Rsubread` library will enable us to go from mapped reads to a count of reads per gene.  The `rtracklayer` library enables us to convert gff files to gtf files.

First we need to install a Linux dependency.  From the Linux command line:

  sudo apt-get install libxml2-dev

Now we can install the R pacakages.  Start Rstudio and enter:

```{r install_subread,eval=FALSE}
  source("http://bioconductor.org/biocLite.R")
	biocLite(c("Rsubread","rtracklayer"))
```

If R asks you about using a personal library, answer "y".  If R asks you if you want to update packages you can answer "n". 

Don't worry about the warning messages.  Do worry if you get a message saying "ERROR could not install."

## Set your working directory

Pull your BIS180L_Assignments repository.

Set your working directory in R to the "Diff_Exp" directory.

## GFF to GTF

There are two closely related file formats that describe genomic features, [GFF](http://www.sequenceontology.org/gff3.shtml) and [GTF](http://mblab.wustl.edu/GTF22.html).  Unfortunately we have a GFF but we need a GTF.  Fortunately the conversion is pretty easy.

Set your working directory to the Brassica_Assignment directory.  Then:

```{r GFF2GTF}
library(rtracklayer)
gff <- import.gff("../Brapa_reference/Brapa_gene_v1.5.gff")
gff #take a look

#create a column "gene_id" that contains the gene name for every entry
gff$gene_id <- regmatches(gff$group,regexpr("Bra[0-9]+$",gff$group))

export(gff,"..Brapa_reference/Brapa_gene_v1.5.gtf",format="gtf")
```

## Bam to read counts

As you know from last week's lab, we mapped RNAseq reads to the _B. rapa_ genome.  In order to ask if reads are differentially expressed between cultivars (IMB211 vs. R500) or treatments (dense planting vs. non-dense planting) we need to know how many reads were sequences from each gene.

To do this we use the bam files (telling us where in the genome the reads mapped) and the .gtf file that we just generated (telling us where the genes are) to figure out which reads belong to which genes.  Thankfully the `Rsubread` package does this for us.  An alternative workflow (not used here) would be to use the python package [`HTSeq`](http://www-huber.embl.de/HTSeq/).  Yet another alternative would have been to map our reads to cDNA fasta files and then use `samtools idxstats` on the bam file.

But for this lab we will use `Rsubread` on the two files from Thursday.  You may need to change the path listed below to make this work.

```{r Rsubread}
library(Rsubread)
readCounts <- featureCounts(
  files=c("../tophat_out-IMB211_All_A01_INTERNODE.fq/accepted_hits_A01.bam","../tophat_out-R500_All_A01_INTERNODE.fq/accepted_hits_A01.bam"),
  annot.ext="../Brapa_reference/Brapa_gene_v1.5.gtf", 
  isGTFAnnotationFile=TRUE,
  GTF.featureType="CDS", # This depends on GTF file.  Often it would be "exon"
  GTF.attrType="gene_id"
  )
```

__Exercise 1__  
Read the help file for feature counts.  Be sure to look at the section "Value" where it describes the output.  
__a__ Provide a line of code that displays the counts of the first 6 genes.  (It is not very interesting because the first genes in the file are on chromosome A03 (strange numbering...) and our bam file only has counts from A01...  )
__b__ The gene `Bra011030` is on chromosome A01.  What are its read counts in the two files?
__c__ What percentage of reads (from each file) were assigned to a gene?  What percentage were unassigned because they were not located in a gene (aka "Feature")?
__d__ What are 2 possible reasons why there are reads that cannot be assigned to a gene?  
```{r Ex1,echo=FALSE,eval=FALSE}
head(readCounts$count)
readCounts$count["Bra011030",]
readCounts$stat
100*readCounts$stat[,-1]/colSums(readCounts$stat[,-1])
```

## Finding differentially expressed genes with edgeR

The steps for finding differnetially expressed genes are to:

1. Load the RNAseq counts.
2. Normalize the counts.
3. QC the counts.
4. Create a data frame that describes the experiment.
5. Determine the dispersion parameter (how over-dispersed is the data?)
6. Fit a statistical model for gene expression as a function of experimental parameters.
7. Test the significance of experimental parameters for explaining gene expression.
8. Examine results

### Get the counts data

We will study gene expression levels in _Brassica rapa_ internodes grown under two treatments, Dense Planting (DP) and Not Dense Planting (NDP).  We will study the response to DP in two cultivars, IMB211 and R500.  Click to download the [internode data]({{site.baseurl}}/data/gh_internode_counts.tsv).  This data set has 12 samples with counts of 40991 genes.

__Exercise 2__  
Move the downloaded data to your current working directory.

__a__. Create a new object in R called `counts.data` with either the leaf data or the internode data.  
__b__. Check to make sure that the data looks as expected.  (What do you expect and how do you confirm?  Show your commands and output.)

```{r import_data,echo=FALSE}
counts.data <- read.delim("../data/gh_internode_counts.tsv")
summary(counts.data)
dim(counts.data)
```

You may have noticed that the first row is labelled "*".  These are the reads that did not map to a gene.  Let's remove this row from the data.  Also lets replace any "NA" records with "0" because that is really what is meant in this case

```{r remove*}
counts.data <- counts.data[rownames(counts.data)!="*",]
counts.data[is.na(counts.data)] <- 0
```


__Exercise 3__  
The column names are too long.  Use the `sub()` command to remove the ".1_matched.merged.fq.bam" suffix from each column name.  Although it doesn't matter in this case, using the argument "fixed=TRUE" is a good idea because "." is a wildcard character.

When you are done, then typing `names(counts.data)` should give results below

```{r ex3,echo=FALSE}
colnames(counts.data) <- sub(".1_matched.merged.fq.bam","",colnames(counts.data),fixed=TRUE)
names(counts.data)
```

### Data exploration

__Exercise 4__
Make a histogram of counts for each of the samples.  Is the data normally distributed?  Apply an appropriate transformation if needed and make a new set of histograms.  __Hint 1__: _see the use of the `melt()` function in the Rice-SNP lab_.  __Hint 2__: _You can transform the axes in ggplot by adding `scale_x_log10()` or `scale_x_sqrt()` to the plot.  One of these should be sufficient if you need to transorm, but for other ideas see the [Cookbook for R page](http://www.cookbook-r.com/Graphs/Axes_%28ggplot2%29/#axis-transformations-log-sqrt-etc)_.  

```{r Ex4, eval=FALSE,echo=FALSE}
library(reshape2)
library(ggplot2)
counts.melt <- melt(counts.data)
head(counts.melt)
pl <- ggplot(data=counts.melt,aes(x=value))
pl <- pl + facet_wrap( ~ variable)
pl <- pl + geom_histogram()
pl
pl + scale_x_sqrt()  # nope!
pl + scale_x_log10() # Ahhh.  Looks good, although an abundance of low read samples.
```

For our subsequent analyses we want to reduce the data set to only those genes with some expression.  In this case we will ask for > 10 reads in >= 3 samples

```{r reduce_data}
counts.data <- counts.data[rowSums(counts.data > 10) >= 3,]
```

__Exercise 5:__  
We expect that read counts, especially from biological replicates, will be highly correlated.  Check to see if this is the case using the `pairs()` function and the `cor()`.  Function.  Explain what each of these functions does and comment on the results.  __Important Hint 3:__ _`pairs` is slow on the full dataset.  Try it on the first 1,000 genes.  Do you need to transform?_

```{r Ex 5, echo=FALSE,eval=FALSE}
pairs(log10(counts.data[1:1000,]))
cor(counts.data)
```

### Data normalization

In this section, we will normalize the counts data and determine how normalization influences the overall distribution of gene expression data. Data normalization is used in the analysis of differential gene expression using statistical models to account for differences in sequencing depth between samples, differences in the distribution of counts between different samples, and (sometimes) differences in the lengths of genes across the genome. Two commonly performed normalization methods used to analyze RNA seq data are RPKM (Reads per Kilobase per Million) and TMM (Trimmed Mean of M Values). RPKM and TMM will be discussed in lecture, but we will only test TMM in lab since TMM normalization is required for edgeR, and because RPKM has a number of unfortunate qualities. Normalized and unnormalized data will be visualized using boxplots.

#### Assign Groups

Before we can normalize the data we need to be able to tell edgeR which groups the samples belong to.  Here group refers to the distinct sample types (i.e. combinations of genotype and treatment), not considering biorep.  In a later step we will need to tell edgeR our experimental design (the treatment and genotype relevant for each sample).  Here we create a data.frame with both group, genotype, and treatment info.  We use the powerful search features of regular expressions.  There is a reasonable tutorial [here](https://bioinfomagician.wordpress.com/category/regular-expression/).  Regular expressions are a very important tool found in Linux, perl, python, and R.

```{r sample_descriptons}
sample.description <- data.frame(
  sample=colnames(counts.data),
  
  #This next line searches for IMB211 or R500 in the colnames of counts.data and returns anything that matches
  #In this way we can extract the genotype info.
  gt=regmatches(colnames(counts.data),regexpr("R500|IMB211",colnames(counts.data))),
  
  #Now we use the same method to get the treatment
  trt=regmatches(colnames(counts.data),regexpr("NDP|DP",colnames(counts.data)))
  )

# Now we can paste the trt and gt columns together to give a group identifier
sample.description$group <- paste(sample.description$gt,sample.description$trt,sep="_")

sample.description
```

#### Calculate normalization factors

Now we use the edgeR function `calcNormFactors()` to calculate the effective library size and normalization factors using the TMM method on our counts data.  First we create a DGEList object, which is an object class defined by edgeR to hold the data for differential expression analysis.

```{r normFactor, comment=""}
library(edgeR)
dge.data <- DGEList(counts=counts.data, group=sample.description$group)
dim(dge.data) 
dge.data <- calcNormFactors(dge.data, method = "TMM")
dge.data$samples # look at the normalization factors
```

#### Make a plot of the Biological Coefficient of Variation of each sample
Statistically significant differential expression is assessed based on variance both within and between treatments. There are two sources of variance in between replicate RNA samples - **technical variance** and **biological variance**. 

Technical variance usually decreases as the number of total gene counts increases. Biological variance, however, will not change even if total library size increases. One way of analyzing the variation in a dataset is to look at the coefficient of variation (CV), or the variation related to the average value of the whole population (so, CV is calculated as standard deviation divided by the mean).  We can also look at the CV of the biological variance, or BCV.  A reliable estimate of the Biological Coefficient of Variation is required for realistic assessment of differential expression in RNA-seq experiments.

We can use the BCV to calculate the distance between samples based on their gene expression.  Similar to the SNP data set we have a high dimension data set.  Like the SNP dataset we can use multi-dimensional scaling to plot the distances in 2 dimensions.


```{r MDS}
plotMDS(dge.data, method = "bcv") 
```

__Exercise 6__  
Discuss the MDS plot.  Does this give you confidence in the experiment?

__Exercise 7__  

We can extract the normalized data with:

```{r}
counts.data.normal <- cpm(dge.data)
```

To get a graphical idea for what the normalization eie, make box plots of the count data for each sample before and after normalization.  Discuss the effect of normalization.

__Hint 1__: _log2 transform the counts before plotting.  Add a value of "1" before log2 tranforming to avoid having to take the log2 of 0.  Your transformation will look something like this:

```{r}
counts.data.log <- log2(counts.data + 1)
```

__Hint 2__: _If you don't want to bother with melting before going to ggplot, you can just use the `boxplot()` function and feed it the (transformed) matrix directly._

```{r Ex 8,eval=FALSE,echo=FALSE}
boxplot(log2(counts.data + 1),main="counts before transformation",ylab = "log2(counts)")
boxplot(log2(counts.data.normal + 1),main="cpm after transformation",ylab = "log2(cpm)")
```

#### Calculate dispersion factors

