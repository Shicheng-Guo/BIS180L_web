---
type: lab
hidden: true
title: Differential Gene Expression from Illumina RNAseq
output: html_document
---

## Background

The principle behind calling differentially expressed genes is similar to that for other hypothesis-based tests such as ANOVA or t-tests.  We will call genes differentially expressed if the mean expression between treatments is larger than would be expected by chance given the amount of variance among replicates within a treatment type.  However there are several important issues to consider: the first is multiple testing.  Imagine doing a t-test for differential expression on 30,000 genes.  At p < .05 you would expect 5% (600!) of the genes to be called as significantly different by random chance.  This is known as the multiple testing problem and the p-values must be adjusted to compensate for the large number of tests.  Second there are typically very few replicates per treatment reducing power; thankfully techniques have been developed to “share” information between genes to somewhat deal with this issue.  Third, the methods developed for microarray analysis are not directly applicable. Log-transformed microarray data can be effectively modeled as normally distributed.  In contrast RNAseq data is count data and therefore has a different (non-normal) numerical distribution. Consequently statistical models require a different error distribution.

At first glance one might think that the [Poisson distribution](http://en.wikipedia.org/wiki/Poisson_distribution) would be an appropriate model for RNAseq data: reads are discrete events and the chance of a read landing in any particular gene is very low.  Indeed Poisson models were originally tried.  However, in the Poisson distribution the expected mean and variance should be equal.  For most RNAseq data this is not true; the data is overdispersed: the variance is larger than the mean.  Alternatives are the [Negative Binomial](http://en.wikipedia.org/wiki/Negative_binomial_distribution) and Quasi-Poisson models.

It is important to consider an appropriate measure of expression.  While some favor RPKM (Reads per kilobase exon length per million reads mapped), for finding DE genes it is better to normalize counts between samples using a different method (discussed below) and to not adjust for gene length.  Why?  1) the number of reads is not always a linear function of gene length. 2) dividing by gene length causes a loss of information.  By RPKM a gene of 1kb with 10 counts would be treated the same as a 100bp gene with 1 count, but clearly we are much more confident of the expression level when we have 10 counts instead of 1.  This information is lost in RPKM.

Regarding normalization between samples, genes with very high expression levels can skew RPKM type normalization.  Consider two samples where gene expression is the same except that in the first sample RUBISCO is expressed at a very high level, taking up half of the reads.  In the second sample RUBISCO is expressed at a lower level, accounting for 25% of the reads.  By RPKM all non RUBISCO genes will appear to be expressed more highly in the second sample because RUBISO “takes up” fewer reads.  Methods such as [TMM normalization](http://genomebiology.com/2010/11/3/R25) can account for this.

The two packages that I am aware of that effectively deal with the above issues are [DESeq](http://bioconductor.org/packages/release/bioc/html/DESeq.html) and [edgeR](http://www.bioconductor.org/packages/release/bioc/html/edgeR.html), both available through [Bioconductor](http://bioconductor.org/).  We will use edgeR for today's exercises.  


## Preliminaries

We need a couple of additional Bioconductor libraries.  The `Rsubread` library will enable us to go from mapped reads to a count of reads per gene.  The `rtracklayer` library enables us to convert gff files to gtf files.

First we need to install a Linux dependency.  From the Linux command line:

  sudo apt-get install libxml2-dev

Now we can install the R pacakages.  Start Rstudio and enter:

```{r install_subread,eval=FALSE}
  source("http://bioconductor.org/biocLite.R")
	biocLite(c("Rsubread","rtracklayer"))
```

If R asks you about using a personal library, answer "y".  If R asks you if you want to update packages you can answer "n". 

Don't worry about the warning messages.  Do worry if you get a message saying "ERROR could not install."

## Set your working directory

Pull your BIS180L_Assignments repository.

Set your working directory in R to the "Diff_Exp" directory.

## GFF to GTF

There are two closely related file formats that describe genomic features, [GFF](http://www.sequenceontology.org/gff3.shtml) and [GTF](http://mblab.wustl.edu/GTF22.html).  Unfortunately we have a GFF but we need a GTF.  Fortunately the conversion is pretty easy.

Set your working directory to the Brassica_Assignment directory.  Then:

```{r GFF2GTF}
library(rtracklayer)
gff <- import.gff("../Brapa_reference/Brapa_gene_v1.5.gff")
gff #take a look

#create a column "gene_id" that contains the gene name for every entry
gff$gene_id <- regmatches(gff$group,regexpr("Bra[0-9]+$",gff$group))

export(gff,"..Brapa_reference/Brapa_gene_v1.5.gtf",format="gtf")
```

## Bam to read counts

As you know from last week's lab, we mapped RNAseq reads to the _B. rapa_ genome.  In order to ask if reads are differentially expressed between cultivars (IMB211 vs. R500) or treatments (dense planting vs. non-dense planting) we need to know how many reads were sequences from each gene.

To do this we use the bam files (telling us where in the genome the reads mapped) and the .gtf file that we just generated (telling us where the genes are) to figure out which reads belong to which genes.  Thankfully the `Rsubread` package does this for us.  An alternative workflow (not used here) would be to use the python package [`HTSeq`](http://www-huber.embl.de/HTSeq/).  Yet another alternative would have been to map our reads to cDNA fasta files and then use `samtools idxstats` on the bam file.

But for this lab we will use `Rsubread` on the two files from Thursday.  You may need to change the path listed below to make this work.

```{r Rsubread}
library(Rsubread)
readCounts <- featureCounts(
  files=c("../tophat_out-IMB211_All_A01_INTERNODE.fq/accepted_hits_A01.bam","../tophat_out-R500_All_A01_INTERNODE.fq/accepted_hits_A01.bam"),
  annot.ext="../Brapa_reference/Brapa_gene_v1.5.gtf", 
  isGTFAnnotationFile=TRUE,
  GTF.featureType="CDS", # This depends on GTF file.  Often it would be "exon"
  GTF.attrType="gene_id"
  )
```

__Exercise 1__  
Read the help file for feature counts.  Be sure to look at the section "Value" where it describes the output.  
__a__ Provide a line of code that displays the counts of the first 6 genes.  (It is not very interesting because the first genes in the file are on chromosome A03 (strange numbering...) and our bam file only has counts from A01...  )
__b__ The gene `Bra011030` is on chromosome A01.  What are its read counts in the two files?
__c__ What percentage of reads (from each file) were assigned to a gene?  What percentage were unassigned because they were not located in a gene (aka "Feature")?
__d__ What are 2 possible reasons why there are reads that cannot be assigned to a gene?  
```{r Ex1,echo=FALSE,eval=FALSE}
head(readCounts$count)
readCounts$count["Bra011030",]
readCounts$stat
100*readCounts$stat[,-1]/colSums(readCounts$stat[,-1])
```

## Finding differentially expressed genes with edgeR

The steps for finding differnetially expressed genes are to:

1. Load the RNAseq counts.
2. Normalize the counts.
3. QC the counts.
4. Create a data frame that describes the experiment.
5. Determine the dispersion parameter (how over-dispersed is the data?)
6. Fit a statistical model for gene expression as a function of experimental parameters.
7. Test the significance of experimental parameters for explaining gene expression.
8. Examine results

### Get the counts data

You can choose to study differential expression either in internodes or leafs.  Click to download the [internode data]({{site.baseurl}}/data/gh_internode_counts.tsv) or the [leaf data]({{site.baseurl}}/data/gh_leaf_counts.tsv).  Each of these has 12 samples with counts of 40991 genes.

__Exercise 2__  
Move the downloaded data to your current working directory.

__a__. Create a new object in R called `counts.data` with either the leaf data or the internode data.  
__b__. Check to make sure that the data looks as expected.  (What do you expect and how do you confirm?  Show your commands and output.)

```{r import_data,echo=FALSE}
counts.data <- read.delim("../data/gh_internode_counts.tsv")
summary(counts.data)
dim(counts.data)
```

You may have noticed that the first row is labelled "*".  These are the reads that did not map to a gene.  Let's remove this row from the data.  Also lets replace any "NA" records with "0" because that is really what is meant in this case

```{r remove*}
counts.data <- counts.data[rownames(counts.data)!="*",]
counts.data[is.na(counts.data)] <- 0
```


__Exercise 3__  
The column names are too long.  Use the `sub()` command to remove the ".1_matched.merged.fq.bam" suffix from each column name.  Although it doesn't matter in this case, using the argument "fixed=TRUE" is a good idea because "." is a wildcard character.

When you are done, then typing `names(counts.data)` should give results below

```{r ex3,echo=FALSE}
colnames(counts.data) <- sub(".1_matched.merged.fq.bam","",colnames(counts.data),fixed=TRUE)
names(counts.data)
```

### Data exploration

__Exercise 4__
Make a histogram of counts for each of the samples.  Is the data normally distributed?  Apply an appropriate transformation if needed and make a new set of histograms.  __Hint 1__: _see the use of the `melt()` function in the Rice-SNP lab_.  __Hint 2__: _You can transform the axes in ggplot by adding `scale_x_log10()` or `scale_x_sqrt()` to the plot.  One of these should be sufficient if you need to transorm, but for other ideas see the [Cookbook for R page](http://www.cookbook-r.com/Graphs/Axes_%28ggplot2%29/#axis-transformations-log-sqrt-etc)_.  

```{r Ex4, eval=FALSE,echo=FALSE}
library(reshape2)
library(ggplot2)
counts.melt <- melt(counts.data)
head(counts.melt)
pl <- ggplot(data=counts.melt,aes(x=value))
pl <- pl + facet_wrap( ~ variable)
pl <- pl + geom_histogram()
pl
pl + scale_x_sqrt()  # nope!
pl + scale_x_log10() # Ahhh.  Looks good, although an abundance of low read samples.
```

For our subsequent analyses we want to reduce the data set to only those genes with some expression.  In this case we will ask for > 10 reads in >= 3 samples

```{r reduce_data}
counts.data <- counts.data[rowSums(counts.data > 10) >= 3,]
```

__Exercise 5:__  
We expect that read counts, especially from biological replicates, will be highly correlated.  Check to see if this is the case using the `pairs()` function and the `cor()`.  Function.  Explain what each of these functions does and comment on the results.  __Important Hint 3:__ _`pairs` is slow on the full dataset.  Try it on the first 1,000 genes.  Do you need to transform?_

```{r Ex 5, echo=FALSE,eval=FALSE}
pairs(log10(counts.data[1:1000,]))
cor(counts.data)
```




