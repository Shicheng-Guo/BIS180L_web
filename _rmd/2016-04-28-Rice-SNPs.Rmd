---
title: "Rice SNPs"
layout: lab
tags:
- R
- SNPs
hidden: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

## Getting Started
* I have created a new repository  called `Assignment_4` and have placed an `Assignment_4_template.Rmd` file there.  
* Pull your repository to obtain these changes.
* Download the file [RiceSNPData.zip]({{site.baseurl}}/data/RiceSNPData.zip), unzip it, and place the files into the `Assigment_4` directory.
* Start RStudio.  
* Set the working directory to the `Assignment_4` directory.  You can set the working directory by any of the following 3 methods:
    * Using the `setwd()` command 
    * Choosing "Set working directory" from the "Session" pull-down menu
    * Click on the "Files" tab in the lower right-hand pane, navigate to the folder, then choose "Set working directory" from the "More" menu in the lower right hand pane.
* Open the `Assignment_4_worksheet.Rmd` file and use that for your answers 

## Preliminaries

Let's load the libraries we need:

```{r}
library(tidyverse)
library(stringr)
```

    
## In this lab we split questions into two types

1. __Practice__.  These are important for you to do to get experience with new functions and concepts but will not be graded.  You can include them in your .Rmd if you want to.

2. __Exercise__.  These answers to these questions will be turned in for homework and will be graded.

## Some new tools

We begin by learning a few new tools to help us with the upcoming data sets.
    
### reshaping data.

Spreadsheet data is often organized in a "wide" format where there is one row per individual and then multiple traits measured on that individual are in separate columns.  This is a convenient format for data entry, but R often wants data in a "long" format with one observation per row.  Please work through the Gather And Spread tutorial to learn more about these formats and how to convert:

```{r eval=FALSE}
devtools::install_github("UCDBIS180L/BIS180LTutorials") # needs to be reinstalled to get the new tutorial

learnr::run_tutorial("Gather_And_Spread", package = "BIS180LTutorials") 
```


### applying functions across rows or columns
It is very common to want to apply a function to each row.  We can use the `apply()` function for this.  `apply` takes at least 3 arguments.

`apply(X,MARGIN,FUN)`
where
* X is a data frame or matrix
* MARGIN is whether to apply a function to each row (1) or each column (2)
* FUN is the function that you want to use

For example
```{r}
m <- matrix(rnorm(24),ncol=6) #create a matrix of numbers to illustrate apply
m

cat("\nrow minimums: \n")
apply(m,1,min) # find the minimum value of each row
```


**PRACTICE 4:** find the mean of each _column_ of m using apply

### Alternatives

For some key functions there are pre-defined convience functions

```{r}
rowMeans(m)
colMeans(m)
rowSums(m)
colSums(m)
```

## Lets get started with the real data

### Data Import
You learned how to import data last week using `read_csv()`.  Note that read.csv can read in a .gzipped file directly.  Today we will provide an additional argument to the read_csv function:
```{r import_geno, results='hide', eval=TRUE}
data.geno <- read_csv("../data/Rice_44K_genotypes.csv.gz",
                      na=c("NA","00")) #this tells R that missing data is denoted as "NA" or "00"

#Takes a minute or two to load
```

Use `dim()` to determine the numbers of rows and columns.  (You can also look at the info in the right-hand pane).  There are 413 rows and 36,901 columns.  Generally I recommend looking at files after they have been read in with the `head()` and `summary()` functions but here we must limit ourselves to looking at a subset of what we read in.

```{r summary, eval=FALSE}
head(data.geno[,1:20]) #first six rows of first 20 columns
summary(data.geno[,1:20]) #summarizes the first 20 columns
```

In this file each row represents a different rice variety and each column a different SNP. The column "X1" ("NSFTV1") gives the ID of each variety.  "X1" is not a very informative name (that column did not have a name in the data file and R assigned it the name "X1".) Let's rename it:

```{r}
colnames(data.geno)[1] <- "ID"
head(data.geno[,1:20]) #first six rows of first 20 columns
```

The column names give the chromosome and locations of each SNP.  For example, "1_151492" is a SNP on chromosome 1, base position 151492.

### An MDS Plot.  
Multi-Dimensional Scaling (MDS) plots can be used to display the genetic diversity in a 2D space.  The full 36,901 SNPs take too long to run for this class so we will subset the data.  

To do this we take advantage of the `sample()` function.  Sample takes a random sample of the items it is given.

```{r}
sample(1:10,5) # takes 5 random samples from the numbers 1:10
```

We can use this to randomly sample a data frame by rows or columns.
```{r}
m2 <- matrix(1:100,nrow=10)
m2
```

if we want to randomly sample 3 rows, then:

```{r}
m2[sample(1:10,3),]
```

** Exercise 1 **

Now, create a data subset that contains a random sample of 2500 SNPs from the full data set.  Place the smaller data set in an object called `data.geno.2500`.  __Very important: you want to keep the first column, the one with the variety IDs, and you want it to be the first column.  AND You do not want it to show up randomly later on in the data set.__  Think about how to achieve this.

Check the dimensions of your subset.  If you don't get the output below, you did something wrong:

```{r subset,echo=FALSE, results='hide'}
#first create a smaller dataset by randomly picking 2500 columns
data.geno.2500 <- data.geno[,c(1,sample(x=2:ncol(data.geno),size=2500))]
```

```{r check_subset}
dim(data.geno.2500)
```

Make sure that "ID" is the first column
```{r}
colnames(data.geno.2500) %>% str_which("ID") #returns the position of entries that match "ID".
```


Now that we have our smaller subset we can create the MDS plot
```{r MDS, eval=FALSE}
#convert the data matrix to numbers
geno.numeric <- data.geno.2500[,-1] %>% # -1 to remove the first column, with names.
  lapply(factor) %>% # convert charcters to "factors", where each category is internally represented as a number
  as.data.frame() %>% # reformat
  data.matrix() #  conver to numeric

head(geno.numeric[,1:20])

#calculate the Euclidian distance between each rice variety
genDist <- as.matrix(dist(geno.numeric))

#perform the multi-dimensional scaling
geno.mds <- as.tibble(cmdscale(genDist))

#Add the variety ID back into this
geno.mds$ID <- data.geno.2500$ID 
head(geno.mds) #now we have 2 dimensions + the ID
```
`geno.mds` contains the genotypic information rescaled to display in two dimensions.  Now lets plot it.  Make a x-y scatter plot of the data, with "V1" on one axis and "V2" on the other axis.

```{r mdsPlot, results='hide', eval=FALSE, echo=FALSE}
qplot(x=V1,y=V2,data=geno.mds,geom="point")
```

**EXERCISE 2:** Is there any evidence for populations structure (different sub populations)?  If so, how many sub populations do you think the MDS plot reveals?  What do you make of the individuals that are between the major groups?

```{r PCA_Alternative, eval=FALSE,echo=FALSE}
##Alternative method for PCA
##Not used 2013

#you must reduce the number of SNPS to be < = the number of observations
geno.small <- geno.numeric[,sample(1:nrow(geno.numeric),size=nrow(geno.numeric))]
geno.small[is.na(geno.small)] <- 0 #missing values not allowed
geno.pc <- prcomp(geno.small)

#Show variance explained by top PCs
plot(geno.pc)

#The PCs themselves are here
head(geno.pc$x)

#you can relate back to the original SNPs by:
head(geno.pc$rotation) #tell you how much each SNP contributed to each PC

pheno.PC <- merge(data.pheno,geno.pc$x,by="row.names")

library(ggplot2)
qplot(x=PC1,y=PC2,color=Region,data=pheno.PC) + scale_color_brewer(type="div")
qplot(x=PC1,y=PC3,color=Region,data=pheno.PC) + scale_color_brewer(type="div")
```

### Adding phenotypes

The file "RiceDiversity.44K.MSU6.Phenotypes.csv" contains information about the country of origin and phenotypes of most of these varieties.  

**EXERCISE 3:** 
* Use the `read_csv()` `head()` and `summary()` functions that you learned earlier to import and look at this file.  Import the file into an object called "data.pheno".
* Use a `join` function to merge the MDS scaled genotype data with the phenotype data. Use summary and head to look at the new object and make sure that it is as you expect.
* Include your code in the .Rmd

```{r read_pheno, echo=FALSE, results='hide', eval=FALSE}
data.pheno <- read_csv("../data/RiceDiversity.44K.MSU6.Phenotypes.csv")
head(data.pheno)
summary(data.pheno)
```

```{r merge, results='hide', eval=FALSE, echo=FALSE}
data.pheno.mds <- geno.mds %>% left_join(data.pheno,by=c("ID"="NSFTVID"))
```

```{r check_merge, results='hide',echo=FALSE, eval=FALSE}
summary(data.pheno.mds)
head(data.pheno.mds)
```
We can now color points on our plot by characteristics in this data set.  

**EXERCISE 4:** Prepare three different plots to explore if subgroups vary by 1) Amylose content; 2) Pericarp color; 3) Region.  Do any of these seem to be associated with the different population groups? Briefly discuss.

*Hint 1* to refer to column names with spaces in the name you can surround the name with backticks, like this:

```{r, eval=FALSE}
data.pheno.mds %>% ggplot(aes(x=`Protein content`, y=`Amylose content`)) +
  geom_point()
``` 


*Hint 2* use `color=` argument ggplot to color the point by the different traits

*Hint 3* use `size=I(3)` as an argument to increase the point size (you can play with different values)

*Hint 4* when plotting the Region data, the colors will be easier to interpret if you include the following in your ggplot code: ` + scale_color_brewer(type="div")` This specifies that a diverging set of colors is used.  (Try plotting with and without this).


```{r MDS_color, results='hide', eval=FALSE,echo=FALSE}
qplot(x=V1,y=V2,color=`Amylose content`,data=data.pheno.mds,size=I(3))
qplot(x=V1,y=V2,color=`Pericarp color`,data=data.pheno.mds,size=I(3))
qplot(x=V1,y=V2,color=Region,data=data.pheno.mds,size=I(3))
```


## PSMix: Assigning varieties to populations.
From the MDS plot it looks like there is structure in our population.  But how do we know which individual belongs in which population?  We can take an alternative approach and assign individuals to specific population classes with [PSMix](http://www.biomedcentral.com/1471-2105/7/317) package.

First we have to convert our genotypes to the form that PSMix expects.  PSMix wants a separate row for each allele (two rows for each variety).  A couple of the commands below are a bit complex.  I will explain them in lab after this has been run.

```{r convert_PSMix, results='hide',eval=FALSE}
#Convert to character matrix.  The apply function applies a function (in this case as.character()) either to every column or every row in the data.
data.geno.2500.c <- apply(data.geno.2500,2,as.character)

#Create a new Matrix to hold reformatted data
data.geno.2500.ps <- matrix("",nrow=nrow(data.geno.2500.c)*2,ncol=ncol(data.geno.2500.c))

#for each row of genotypes, create 2 rows, one with the first allele and one with the second allele.
for (i in 1:nrow(data.geno.2500.c)) {
  data.geno.2500.ps[(i-1)*2+1,] <- substr(data.geno.2500.c[i,],1,1)
  data.geno.2500.ps[(i-1)*2+2,] <- substr(data.geno.2500.c[i,],2,2)
  }
```
Now we can run PSMix.  PSMix will determine the proportion of each individual's genome that came from one of K ancestral populations.  This can take a long time to run, so you can just import the results of my previous run of the analysis if you prefer.  This files should be in the zip that you downloaded.


```{r PSMix5,results='hide',eval=FALSE}
library(PSMix)

#load in my pre-run data
load("ps4.2500.RData")

#if you prefer, uncomment the lines below to run on your own.
#run on K=4 popultions and 2500 markers; may take 15-30 minutes
#system.time(ps4 <- PSMix(K=4,data.geno.2500.ps,eps=1e-05,verbose=T))
#save(ps4,file="../data/ps4.2500.RData")

#2500 markers K = 5 > 1 hour run time
#system.time(ps5 <- PSMix(K=5,data.geno.2500.ps,eps=1e-05,verbose=T))
#save(ps5,file="../data/ps5.2500.RData")
```

Now examine the output.
```{r PSMix_out,results='hide',eval=FALSE}
names(ps4) #shows us elements within ps4
head(ps4$AmPr) 
round(head(ps4$AmPr),3) #round to 3 decimal places to make it easier to see
```
In the AmPr table, each row is an individual and each column represents one of the hypothesized populations.  
Genomes with substantial contributions from two ancestral genomes are said to be admixed

The second component, AmID, shows an assignment of each individual to a single ancestral population.  Of course this can be somewhat problematic for heavily admixed individuals.
```{r PSMix_out2,results='hide',eval=FALSE}
head(ps4$AmId)
```

If you want to know how many individuals were assigned to each population, you can use `table()`
```{r table,eval=FALSE}
table(ps4$AmId)
```

The PSMix output must be reformatted in order to plot it well.  Not all of the commands are fully explained below.  If you have questions we can go over this in Friday's discussion.

The first step is to combine the useful columns from PSMix together into a single data frame.  This is accomplished using `cbind()` ("column bind") to paste the columns together.
```{r ps_reformat1, results='hide',eval=FALSE}
ps4.df <- as.data.frame(cbind(round(ps4$AmPr,3),ps4$AmId))
head(ps4.df) #look at the new data frame

#Next add useful column names
colnames(ps4.df) <- c(paste("pop",1:(ncol(ps4.df)-1),sep=""),"popID")
head(ps4.df) #look at the new data frame
```

For plotting it will be helpful to order the samples based on population identity and composition.  First we calculate the largest proportion of the genome from a single ancestral population for each individual.  This is done using `apply()`, which *applies* a function across every row or column of a data frame.  You were introduced to this function earlier in the lab.

```{r ps_reformat2,results='hide',eval=FALSE}
maxGenome <- apply(ps4$AmPr,1,max) 

#now we order the varieties by their prediced population membership and their degree of admixture.
ps4.df <- ps4.df[order(ps4.df$popID,-maxGenome),]
#Add a column for sample index
ps4.df$sampleID <- factor(1:413)
head(ps4.df)
```

The next step is to take the data from "wide" format to "long" format.  `qplot()` needs one observation per row, whereas now we have 5 observations per row.  We use `melt()` as described at the beginning of this tutorial.
```{r ps_reformat3,results='hide',eval=FALSE}
library(reshape2)
ps4.df.melt <- melt(ps4.df,id.vars=c("popID","sampleID"))
head(ps4.df.melt) #look a the melted data set.
```

Finally we are ready to plot the results.  In the plot produced below, each column is a single rice variety. The colors correspond to ancestral genomes.  Do you see any evidence of admixture?
```{r plot_PSMix data,results='hide',eval=FALSE}
library(ggplot2)

pl <- ggplot(aes(x=sampleID, y=value, color=variable, fill=variable), data=ps4.df.melt)
pl <- pl + geom_bar(stat="identity") 
pl <- pl + ylab("genome proportion") + scale_color_brewer(type="div") + scale_fill_brewer(type="div")

pl
```

### How do these population assignments relate to the MDS plot? 

It would be interesting to see how the assigned population ancestry relates to the MDS plot.  You can add the population predictions to the mds information using this code:
```{r AddpopToMDS,results='hide',eval=FALSE}
geno.mds$popID <- factor(ps4$AmId) #this only works because the order of the varieties is the same in geno.mds and ps4
head(geno.mds$popID)
#Also add the admixture proportions for future use
#first give them some useful names
colnames(ps4$AmPr) <- paste("pr",1:4,sep="")

geno.mds <- cbind(geno.mds,ps4$AmPr)
head(geno.mds)
```

**EXERCISE 5:** Re plot the MDS data, but include the population assignment in an informative way.  How do the populations assignments relate to the MDS plot?

```{r eval=FALSE,echo=FALSE}
qplot(x=V1,y=V2,color=popID,data=geno.mds,geom="point",size=I(3)) + scale_color_brewer(type="div")
```

We will use some of the objects that you have created today in Thursday's lab, so lets save them in an .Rdata file for easy loading on Thursday

```{r eval=FALSE}
save(data.pheno,geno.mds,file="data_from_SNP_lab.Rdata")
```

